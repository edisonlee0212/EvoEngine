#extension GL_ARB_shading_language_include : enable

#include "Trace.glsl"


struct Environment {
	vec4 background_color;
	float gamma;
	float light_intensity;
	float padding1;
	float padding2;
};

layout(set = EE_PER_FRAME_SET, binding = 1) uniform EE_ENVIRONMENTAL_BLOCK
{
	Environment EE_ENVIRONMENT;
};

struct Camera {
	mat4 projection;
	mat4 view;
	mat4 projection_view;
	mat4 inverse_projection;
	mat4 inverse_view;
	mat4 inverse_projection_view;
	vec4 clear_color;
	vec4 reserved1;
	vec4 reserved_2;
	int skybox_tex_index;
	int irradiance_map_index;
	int prefiltered_map_index;
	int use_clear_color;
};

//Camera
layout(set = EE_PER_FRAME_SET, binding = 2) readonly buffer EE_CAMERA_BLOCK
{
	Camera EE_CAMERAS[];
};

struct MaterialProperties {
	int albedo_map_index;
	int normal_map_index;
	int metallic_map_index;
	int roughness_map_index;

	int ao_texture_index;
	bool cast_shadow;
	bool receive_shadow;
	bool enable_shadow;

	vec4 albedo;
	vec4 sss_c;
	vec4 sss_r;

	float metallic;
	float roughness;
	float ambient_occulusion;
	float emission;
};

layout(set = EE_PER_FRAME_SET, binding = 3) readonly buffer EE_MATERIAL_BLOCK
{
	MaterialProperties EE_MATERIAL_PROPERTIES[];
};

struct Instance {
	mat4 model;
	uint material_index;
	uint info_index;
	uint meshlet_offset;
	uint meshlet_size;
};

layout(set = EE_PER_FRAME_SET, binding = 4) readonly buffer EE_INSTANCE_BLOCK
{
	Instance EE_INSTANCES[];
};

//Lights
struct DirectionalLight {
	vec3 direction;
	vec4 diffuse;
	vec3 specular;
	mat4 light_space_matrix[4];
	vec4 light_frustum_width;
	vec4 light_frustum_distance;
	vec4 reserved_parameters;
	int viewport_x_offset;
	int viewport_y_offset;
	int viewport_x_size;
	int viewport_y_size;
};

struct PointLight {
	vec3 position;
	vec4 constant_linear_quadratic_far;
	vec4 diffuse;
	vec3 specular;
	mat4 light_space_matrix[6];
	vec4 reserved_parameters;
	int viewport_x_offset;
	int viewport_y_offset;
	int viewport_x_size;
	int viewport_y_size;
};

struct SpotLight {
	vec3 position;
	float padding0;

	vec3 direction;
	float padding1;

	mat4 light_space_matrix;
	vec4 cutoff_outer_inner_size_bias;
	vec4 constant_linear_quadratic_far;
	vec4 diffuse;
	vec3 specular;
	float padding3;
	int viewport_x_offset;
	int viewport_y_offset;
	int viewport_x_size;
	int viewport_y_size;
};
layout(set = EE_PER_FRAME_SET, binding = 5) uniform EE_KERNEL_BLOCK
{
	vec4 EE_UNIFORM_KERNEL[MAX_KERNEL_AMOUNT];
	vec4 EE_GAUSS_KERNEL[MAX_KERNEL_AMOUNT];
};

layout(set = EE_PER_FRAME_SET, binding = 6) readonly buffer EE_DIRECTIONAL_LIGHT_BLOCK
{
	DirectionalLight EE_DIRECTIONAL_LIGHTS[];
};

layout(set = EE_PER_FRAME_SET, binding = 7) readonly buffer EE_POINT_LIGHT_BLOCK
{
	PointLight EE_POINT_LIGHTS[];
};

layout(set = EE_PER_FRAME_SET, binding = 8) readonly buffer EE_SPOT_LIGHT_BLOCK
{
	SpotLight EE_SPOT_LIGHTS[];
};




layout(std140, binding = 12) readonly buffer RAYS_BLOCK{
	vec4 rays[];
};

layout(std140, binding = 13) writeonly buffer RAY_CASTING_RESULTS_BLOCK{
	vec4 ray_casting_results[];
};

layout(push_constant) uniform RAY_CASTING_CONSTANTS{
	vec4 ray_cast_config;
};

void Execute(uint current_ray_index);

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main() {
	uint current_ray_index = gl_GlobalInvocationID.x;
	Execute(current_ray_index);
}

void Execute(uint current_ray_index) {
	uint rays_count = floatBitsToUint(ray_cast_config.z);
	if (current_ray_index < rays_count) {
		vec3 sample_origin = rays[current_ray_index * 2].xyz;
		vec3 sample_direction = rays[current_ray_index * 2 + 1].xyz;
		RayDescriptor ray_descriptor;
		ray_descriptor.origin = sample_origin;
		ray_descriptor.direction = sample_direction;
		ray_descriptor.t_min = rays[current_ray_index * 2].w;
		ray_descriptor.t_max = rays[current_ray_index * 2 + 1].w;
		bool hit = false;
		HitInfo hit_info = Trace(ray_descriptor, ray_cast_config.x, ray_cast_config.y, hit);
		if (hit) {
			ray_casting_results[current_ray_index * 4] = vec4(hit_info.hit, 1);
			ray_casting_results[current_ray_index * 4 + 1] = vec4(hit_info.barycentric, hit_info.back_face ? 1.0 : 0.0);
			ray_casting_results[current_ray_index * 4 + 2] = vec4(hit_info.normal, hit_info.hit_dist);
			ray_casting_results[current_ray_index * 4 + 3] = vec4(uintBitsToFloat(hit_info.node_index), uintBitsToFloat(hit_info.mesh_index), uintBitsToFloat(hit_info.triangle_index), 0.0);
		}
	}
}
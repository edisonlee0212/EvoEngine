#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_ARB_shading_language_include : enable
#extension GL_EXT_control_flow_attributes : require

#define DYNAMIC_STRANDS_SET 0
#include "DynamicStrands.glsl"

const uint WORKGROUP_SIZE = EXT_TASK_SUBGROUP_COUNT * EXT_TASK_SUBGROUP_SIZE;

const uint ITERATIONS_PER_TASK = ((EXT_INVOCATIONS_PER_TASK + WORKGROUP_SIZE - 1) / WORKGROUP_SIZE);

uint baseID = gl_WorkGroupID.x * EXT_INVOCATIONS_PER_TASK;
uint laneID = gl_LocalInvocationID.x;

layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

#define BARRIER() \
memoryBarrierShared(); \
barrier();

layout(push_constant) uniform PUSH_CONSTANTS {
	uint constraint_size;
	float time_step;
	float inv_time_step;
};

#define DYNAMIC_STRANDS_PHYSICS_SET 1
#include "DynamicStrandsPhysics.glsl"

void init_constraint(in uint rod_constraint_handle);
//Line 52
void main(){

	[[unroll]]
	for (uint i = 0; i < ITERATIONS_PER_TASK; i++)
	{
		uint local_index  = laneID + i * WORKGROUP_SIZE;
		uint constraint_index = baseID + local_index;

		if(constraint_index >= constraint_size) break;
		init_constraint(constraint_index);
	}
}

void init_constraint(in uint rod_constraint_handle){
	RodConstraint rod_constraint = rod_constraints[rod_constraint_handle];
			
	vec3 stretch_compliance;
	vec3 bending_and_torsion_compliance;
	vec6 lambda_sum;

	init_stretch_bending_twisting_constraint(
		rod_constraint.stiffness_coefficient_k_segment0_index.xyz, 
		inv_time_step,
		rod_constraint.stretch_compliance_average_segment_length.w,
		stretch_compliance,
		bending_and_torsion_compliance,
		lambda_sum);

	rod_constraints[rod_constraint_handle].stretch_compliance_average_segment_length.xyz = stretch_compliance;
	rod_constraints[rod_constraint_handle].bending_and_torsion_compliance_next_constraint_handle.xyz = bending_and_torsion_compliance;

	rod_constraints[rod_constraint_handle].lambda_sum0 = lambda_sum.v[0];
	rod_constraints[rod_constraint_handle].lambda_sum1 = lambda_sum.v[1];
	rod_constraints[rod_constraint_handle].lambda_sum2 = lambda_sum.v[2];
	rod_constraints[rod_constraint_handle].lambda_sum3 = lambda_sum.v[3];
	rod_constraints[rod_constraint_handle].lambda_sum4 = lambda_sum.v[4];
	rod_constraints[rod_constraint_handle].lambda_sum5 = lambda_sum.v[5];

}
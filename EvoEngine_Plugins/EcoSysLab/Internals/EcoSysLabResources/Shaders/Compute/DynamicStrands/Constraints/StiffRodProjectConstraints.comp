#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_ARB_shading_language_include : enable
#extension GL_EXT_control_flow_attributes : require
#define DYNAMIC_STRANDS_SET 0
#include "DynamicStrands.glsl"

const uint WORKGROUP_SIZE = EXT_TASK_SUBGROUP_COUNT * EXT_TASK_SUBGROUP_SIZE;

const uint ITERATIONS_PER_TASK = ((EXT_INVOCATIONS_PER_TASK + WORKGROUP_SIZE - 1) / WORKGROUP_SIZE);

uint baseID = gl_WorkGroupID.x * EXT_INVOCATIONS_PER_TASK;
uint laneID = gl_LocalInvocationID.x;

layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

#define BARRIER() \
memoryBarrierShared(); \
barrier();

layout(push_constant) uniform PUSH_CONSTANTS {
	uint strand_size;
};

#define DYNAMIC_STRANDS_PHYSICS_SET 1
#include "DynamicStrandsPhysics.glsl"

void project_constraint(in int rod_constraint_handle);

void main(){

	[[unroll]]
	for (uint i = 0; i < ITERATIONS_PER_TASK; i++)
	{
		uint local_index  = laneID + i * WORKGROUP_SIZE;
		uint strand_index = baseID + local_index;

		if(strand_index >= strand_size) break;

		PerStrandData strand_data = per_strand_data_list[strand_index];
		int rod_constraint_handle = strand_data.begin_rod_constraint_handle;
		while(rod_constraint_handle != strand_data.end_rod_constraint_handle){
			project_constraint(rod_constraint_handle);
			rod_constraint_handle = floatBitsToInt(rod_constraints[rod_constraint_handle].bending_and_torsion_compliance_next_constraint_handle.w);
		}
		project_constraint(rod_constraint_handle);
	}
}

void project_constraint(in int rod_constraint_handle){
	RodConstraint rod_constraint = rod_constraints[rod_constraint_handle];

	vec3 x0_correction, x1_correction;
	vec4 q0_correction, q1_correction;
	vec6 lambda_sum;
	lambda_sum.v[0] = rod_constraint.lambda_sum0;
	lambda_sum.v[1] = rod_constraint.lambda_sum1;
	lambda_sum.v[2] = rod_constraint.lambda_sum2;
	lambda_sum.v[3] = rod_constraint.lambda_sum3;
	lambda_sum.v[4] = rod_constraint.lambda_sum4;
	lambda_sum.v[5] = rod_constraint.lambda_sum5;

	int segment0_handle = floatBitsToInt(rod_constraint.stiffness_coefficient_k_segment0_index.w);
	int segment1_handle = floatBitsToInt(rod_constraint.rest_darboux_vector_segment1_index.w);
	StrandSegment segment0 = strand_segments[segment0_handle];
	StrandSegment segment1 = strand_segments[segment1_handle];

	mat3 inverse_inertia_tensor_w0, inverse_inertia_tensor_w1;
	inverse_inertia_tensor_w0 = mat3(segment0.inv_inertia_w);
	inverse_inertia_tensor_w1 = mat3(segment1.inv_inertia_w);

	solve_stretch_bending_twisting_constraints(
		segment0.inv_inertia_tensor_inv_mass.w, segment0.x.xyz, inverse_inertia_tensor_w0, segment0.q,
		segment1.inv_inertia_tensor_inv_mass.w, segment1.x.xyz, inverse_inertia_tensor_w1, segment1.q,
		rod_constraint.rest_darboux_vector_segment1_index.xyz,
		rod_constraint.stretch_compliance_average_segment_length.w,
		rod_constraint.stretch_compliance_average_segment_length.xyz,
		rod_constraint.bending_and_torsion_compliance_next_constraint_handle.xyz,
		rod_constraint.constraint_info,
		x0_correction, q0_correction,
		x1_correction, q1_correction,
		lambda_sum);

	if(segment0.inv_inertia_tensor_inv_mass.w != 0.0){
		strand_segments[segment0_handle].x.xyz = segment0.x.xyz + x0_correction;
		strand_segments[segment0_handle].q = normalize(segment0.q + q0_correction);
	}

	if(segment1.inv_inertia_tensor_inv_mass.w != 0.0){
		strand_segments[segment1_handle].x.xyz = segment1.x.xyz + x1_correction;
		strand_segments[segment1_handle].q = normalize(segment1.q + q1_correction);
	}

	rod_constraints[rod_constraint_handle].lambda_sum0 = lambda_sum.v[0];
	rod_constraints[rod_constraint_handle].lambda_sum1 = lambda_sum.v[1];
	rod_constraints[rod_constraint_handle].lambda_sum2 = lambda_sum.v[2];
	rod_constraints[rod_constraint_handle].lambda_sum3 = lambda_sum.v[3];
	rod_constraints[rod_constraint_handle].lambda_sum4 = lambda_sum.v[4];
	rod_constraints[rod_constraint_handle].lambda_sum5 = lambda_sum.v[5];
}
#extension GL_ARB_shading_language_include : enable

#define SCENE_LEVEL_BVH_BLOCK_BINDING 0
#define NODE_INDICES_BLOCK_BINDING 1
#define NODE_INFO_LIST_BLOCK_BINDING 2
#define NODE_LEVEL_BVH_NODES_BLOCK_BINDING 3
#define MESH_INDICES_BLOCK_BINDING 4
#define MESH_INFO_LIST_BLOCK_BINDING 5
#define MESH_LEVEL_BVH_NODES_BLOCK_BINDING 6
#define TRIANGLE_INDICES_BLOCK_BINDING 7
#define LOCAL_TRIANGLE_INDICES_BLOCK_BINDING 8
#define SCENE_TRIANGLES_BLOCK_BINDING 9
#define SCENE_VERTEX_POSITIONS_BLOCK_BINDING 10
#define SCENE_INFO_BLOCK_BINDING 11
#include "Trace.glsl"

layout(std140, binding = 12) readonly buffer RAYS_BLOCK{
	vec4 rays[];
};

layout(std140, binding = 13) writeonly buffer RAY_CASTING_RESULTS_BLOCK{
	vec4 ray_casting_results[];
};

layout(push_constant) uniform RAY_CASTING_CONSTANTS{
	vec4 ray_cast_config;
};

void Execute(uint current_ray_index);

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main() {
	uint current_ray_index = gl_GlobalInvocationID.x;
	Execute(current_ray_index);
}

void Execute(uint current_ray_index) {
	uint rays_count = floatBitsToUint(ray_cast_config.z);
	if (current_ray_index < rays_count) {
		vec3 sample_origin = rays[current_ray_index * 2].xyz;
		vec3 sample_direction = rays[current_ray_index * 2 + 1].xyz;
		RayDescriptor ray_descriptor;
		ray_descriptor.origin = sample_origin;
		ray_descriptor.direction = sample_direction;
		ray_descriptor.t_min = rays[current_ray_index * 2].w;
		ray_descriptor.t_max = rays[current_ray_index * 2 + 1].w;
		bool hit = false;
		HitInfo hit_info = Trace(ray_descriptor, ray_cast_config.x != 0.0, ray_cast_config.y != 0.0, hit);
		if (hit) {
			ray_casting_results[current_ray_index * 4] = vec4(hit_info.hit, 1);
			ray_casting_results[current_ray_index * 4 + 1] = vec4(hit_info.barycentric, hit_info.back_face ? 1.0 : 0.0);
			ray_casting_results[current_ray_index * 4 + 2] = vec4(hit_info.normal, hit_info.hit_dist);
			ray_casting_results[current_ray_index * 4 + 3] = vec4(uintBitsToFloat(hit_info.node_index), uintBitsToFloat(hit_info.mesh_index), uintBitsToFloat(hit_info.triangle_index), 0.0);
		}
	}
}